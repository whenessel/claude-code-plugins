---
name: build-context
description: >
  Analyze project source code to build a structured context document.
  Extracts architectural layers, module boundaries, public APIs, and
  dependency maps. Use when starting a new task, onboarding onto
  unfamiliar code, or preparing context for another agent.
allowed-tools: Read, Grep, Glob, Bash, Write
context: fork
---

<!-- prettier-ignore-start -->

# Project Context Analysis

Analyze the project and produce a structured context document.


## Scope

$ARGUMENTS

If no arguments provided, produce a high-level overview of the entire project.
If a scope or task is provided, focus the analysis on relevant areas only.

Parse optional parameters from arguments:

- `--output <path>` → write the document there
- `--deep` → full API surface with signatures and line numbers
- `--shallow` → module names and paths only
- Default output: `.claude/context/<slug>.md`
- Default depth: `normal`


## Step 1: Orient

Determine project type, language(s), structure, and build system.

- List root directory for project markers (package.json, Cargo.toml,
  pyproject.toml, go.mod, pom.xml, \*.sln, Makefile, CMakeLists.txt, etc.)
- Get directory layout 2 levels deep, excluding noise
  (node_modules, .git, dist, build, **pycache**, target, vendor)
- Read the primary README if it exists
- Check for architecture docs (ARCHITECTURE.md, CLAUDE.md, DESIGN.md, ADR-\*.md)

Result: language(s), framework(s), structure pattern (monorepo, single
package, workspace), build system, entry points.


## Step 2: Discover Architectural Layers

Map the project into logical layers or modules.

Do NOT use hardcoded grep patterns for specific languages.
Follow this language-agnostic discovery strategy:

1. **Find module boundaries** — look for the project's natural divisions:
   directories with entry-point files, package manifests, namespace
   declarations, or explicit module definitions.

2. **Identify entry points** — for each module, find the file that defines
   its public surface. Every language has a convention for this.

3. **Determine purpose** — read the entry point and doc comments.

4. **Classify by role** — group into: core/domain, infrastructure,
   adapters/integrations, utilities, config, tests.

For monorepos: start with workspace/package definitions, then analyze
each package as a sub-project.

Depth control:

- `shallow` — top-level modules only, names and paths
- `normal` — modules + key exports + purpose
- `deep` — full public API surface with signatures and line numbers


## Step 3: Extract Public API Surface

For each layer/module, document its public interface.

1. Find the module's entry point / public surface file
2. Search for export/public declarations using the language's conventions
3. Record each public symbol: name, kind, file, line number
4. For complex signatures, read the actual lines — don't guess from grep

Include: exported types, interfaces, functions (signatures only),
constants, re-exports.

Exclude: internal symbols, implementation bodies, test code, generated code.


## Step 4: Map Dependencies

1. For each module, find imports from other project modules (not external)
2. Determine direction: who imports from whom
3. Flag circular dependencies
4. Note data flow direction

Express as: `Module A → Module B` (A depends on B).


## Step 5: Write Context Document

Create the output directory if needed. Use the Write tool (not bash redirects).

Follow this structure:

```markdown
# Context: [Task or Scope Title]

> Generated by context-builder on [date]
> Scope: [what was analyzed]
> Depth: [shallow|normal|deep]

## Project Overview

[1-3 sentences: project type, language(s), frameworks, structure pattern]

## Layers

### [Layer Name]

- **Path:** `relative/path/`
- **Purpose:** [what this layer does]
- **Entry:** `relative/path/to/entry-point`

**Public API:**

| Symbol           | Kind  | File                     | Line |
| ---------------- | ----- | ------------------------ | ---- |
| `SessionManager` | class | `src/session/manager.ts` | 42   |

[repeat for each layer]

## Dependency Map

Layer A → Layer B → Layer C
↘ Layer D

[prose description of data flow and key integration points]

## Files Examined

- `src/session/index.ts` — barrel export, entry point
- `src/session/manager.ts` — SessionManager (lines 30–150)

## Task Notes

[If task-scoped: where to make changes, which APIs to use, risks]
[If general: patterns, conventions, observations, potential issues]
```

ultrathink

<!-- prettier-ignore-end -->
